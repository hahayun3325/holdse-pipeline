118:        entities = np.load(data_path, allow_pickle=True).item()["entities"]
831:                self.log('phase5/weight_sds', loss_weights['sds'].detach(), prog_bar=False)
832:                self.log('phase5/weight_contact', loss_weights['contact'].detach(), prog_bar=False)
833:                self.log('phase5/weight_temporal', loss_weights['temporal'].detach(), prog_bar=False)
834:                self.log('phase5/lr_multiplier', lr_multiplier.detach(), prog_bar=False)
1078:                detached_tensor = batch[key].detach()
1093:                detached_tensor = batch[key].detach()
1293:                    loss_output['loss'] = loss_output['loss'] + weighted_ghop.detach()
1307:                self.log('ghop/stage_numeric', float(stage_numeric).detach(), prog_bar=False)
1308:                self.log('ghop/stage_progress', ghop_info.get('stage_progress'.detach(), 0.0), prog_bar=True)
1309:                self.log('ghop/total_loss', weighted_ghop.item() if isinstance(weighted_ghop, torch.Tensor) else float(weighted_ghop), prog_bar=True)
1315:                        self.log('ghop/sds_loss', sds_value.item(), prog_bar=True)
1323:                        f"  Total loss:       {weighted_ghop.item() if isinstance(weighted_ghop, torch.Tensor) else weighted_ghop:.4f}\n"
1392:                                self.log('phase5/contact_mean', contact_stats['mean'].detach(), prog_bar=False)
1393:                                self.log('phase5/contact_min', contact_stats['min'].detach(), prog_bar=False)
1394:                                self.log('phase5/contact_max', contact_stats['max'].detach(), prog_bar=False)
1395:                                self.log('phase5/contact_std', contact_stats['std'].detach(), prog_bar=False)
1493:                        loss_output["loss"] = loss_output["loss"] + weighted_contact_loss.detach()
1502:                    self.log('phase4/contact_loss', weighted_contact_loss.detach(), prog_bar=True)
1504:                            base_weight * loss_weights['contact'].detach() if self.phase5_enabled else self.w_contact * contact_progress)
1505:                    self.log('phase4/penetration', contact_metrics_accum['penetration'].detach())
1506:                    self.log('phase4/attraction', contact_metrics_accum['attraction'].detach())
1507:                    self.log('phase4/dist_mean', contact_metrics_accum['dist_mean'].detach())
1508:                    self.log('phase4/num_contacts', float(contact_metrics_accum['num_contacts'].detach()))
1509:                    self.log('phase4/num_penetrations', float(contact_metrics_accum['num_penetrations'].detach()))
1577:                        loss_output["loss"] = loss_output["loss"] + loss_sds.detach()
1585:                    if loss_sds.item() > 0:
1586:                        self.log('train/sds_loss', loss_sds.detach(), prog_bar=True)
1646:                        sequence_id = str(sequence_id.item())
1673:                    self.log('phase5/temporal_loss', weighted_temporal.item(), prog_bar=True)
1674:                    self.log('phase5/velocity_loss', temporal_metrics.get('velocity', 0.0).detach(), prog_bar=False)
1675:                    self.log('phase5/acceleration_loss', temporal_metrics.get('acceleration', 0.0).detach(), prog_bar=False)
1676:                    self.log('phase5/camera_motion_loss', temporal_metrics.get('camera_motion', 0.0).detach(), prog_bar=False)
1677:                    self.log('phase5/temporal_adaptive_weight', temporal_metrics.get('adaptive_weight', 1.0).detach(), prog_bar=False)
1684:                            f"  Total loss:       {weighted_temporal.item():.4f}\n"
1734:        #     loss_output['loss'] = torch.add(loss_output['loss'], weighted_ghop.detach())
1758:        self.log('train/loss', final_loss.detach(), prog_bar=True)
1772:                        loss_output[key] = loss_output[key].detach()
1775:        return final_loss.detach()
2816:                out = self.model(s).detach().to("cpu")
